// We are importing the createSlice function from the Redux Toolkit library to help us create a slice of state in the Redux store
import { createSlice } from "@reduxjs/toolkit";
// We are also importing the PayloadAction type from the Redux Toolkit library to help us define the type of the payload in our action creators
import type { PayloadAction } from "@reduxjs/toolkit";
// We are also importing the Pokemon type from our own types file to help us define the type of the pokemon data
import { Pokemon } from "@/types";

// We are defining an interface for our search state, which is a part of the global state in the Redux store
export interface SearchState {
  // We have a state property called "search" that is a string that represents the search term we enter to filter the pokemon list
  search: string;
  // We have another state property called "startUpPokemon" that is an array of Pokemon objects that represents the initial pokemon list we fetch from the API when we load the app
  startUpPokemon: Pokemon[];
}

// We are initializing our search state with some default values
const initialState: SearchState = {
  // Our search term is an empty string by default
  search: "",
  // Our initial pokemon list is an empty array by default
  startUpPokemon: [],
};

// We are creating a slice of state using the createSlice function, which returns an object with a reducer function and some action creators
const searchSlice = createSlice({
  // We give our slice a name "search", which will be used as a prefix for the action types
  name: "search",
  // We give our slice the initial state we defined before
  initialState,
  // We define some reducers, which are functions that take the current state and an action object, and return a new state with some changes based on the action type and payload
  reducers: {
    // We define a reducer called "setSearch" that takes the current state and an action object with a string payload, and returns a new state with the search property updated to the payload value
    setSearch: (state, action: PayloadAction<string>) => {
      // We mutate the state directly using Immer, which is a library that allows us to write simpler code without worrying about immutability
      state.search = action.payload;
    },
    // We define another reducer called "setStartUpPokemon" that takes the current state and an action object with an array of Pokemon objects as payload, and returns a new state with the startUpPokemon property updated to the payload value
    setStartUpPokemon: (state, action: PayloadAction<Pokemon[]>) => {
      // We mutate the state directly using Immer, which is a library that allows us to write simpler code without worrying about immutability
      state.startUpPokemon = action.payload;
    },
  },
});

// We are exporting the action creators that were generated by the createSlice function
// These action creators can be used to dispatch actions that will trigger the reducers we defined in the slice
export const { setSearch, setStartUpPokemon } = searchSlice.actions;

// We are also exporting the reducer function that was generated by the createSlice function
// This reducer function can be used to handle the actions that belong to the slice
// We can also combine this reducer with other reducers using the combineReducers function from Redux Toolkit or Redux
export default searchSlice.reducer;
